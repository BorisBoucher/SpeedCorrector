/*

  GTO/3000GT/Stealth Speedometer corrector
 
  Principle of operation :
   - The Arduino samples the speed signal that normaly goes to the speedometer.
   - The arduino generates an output signal for the speedometer. 
   - By default, the input signal is simply copied on the  output.
   - A push button allows to indicates the real speed of the car (as read with a GPS) : 50km/h (3 pulses), 100km/h (2 pulse), 140km/h (1 pulse)
   - A second push allows to indicates the speed read on the speedo (same as above)
   - The program store this 6 points and build a correction curve
  
  Input signal is generated by the speed sensor that short a transistor to ground to generates pulses.
  The reader must provide a 5V supply voltage with a forward diode to prevent return of 5V from other 
  reader modules.

  Hypothesis : speed sensor generates 2000 pulse/km, so the expected frequency/period are: 
    - @5km/h :     2.7  Hz, 360ms
    - @300km/h : 166.666Hz,   6ms
    - For 1km/h resolution, we need :
      - @300km/h : 259km/h => 143.888Hz, 6.94ms, delta period = 0.94ms
      - => Minimal rez : tick = 0.5ms (500µs)
      - => Maximal counter @ 5km/s : 720 tick
    
    With base frequency of 16Mhz, clock = 0.0625µs => 8000 clock/rez.
    
    Selectec divisor : 1024 => rez = 64µs
    @5km/h : 5625 points

    16 bits counter ok, up to 4.1s => 0.24Hz => 878pt/hour=> 0.4km/h
  
  Measuring input :
    - The input period is measured by the input capture function available on timer 1
    - Timer 1 is a 16 bits counter, thus allowing reading from 64µs up to 65535*65µs=4.1s
    - Timer 1 is configured to divide the CPU frequency by 1024

 Speed limiter remover:
 ---------------------
 In addition to speedometer correction, the correcter also provides a speed limiter remover function.
 The principle is simply to limit the speed input of the ECU to a maximum value configurable in the correcter.
 Once the maximum  
 
 */

#include <EEPROM.h>

#define TICK_VALUE  ((1/16000000.0) * 1024.0)
#define PULSE_PER_KM  2000
#define PERIOD_50  ((1.0/((PULSE_PER_KM * 50.0) / 3600.0)) / (TICK_VALUE))
#define PERIOD_100  ((1.0/((PULSE_PER_KM * 100.0) / 3600.0)) / (TICK_VALUE))
#define PERIOD_150  ((1.0/((PULSE_PER_KM * 150.0) / 3600.0)) / (TICK_VALUE))

#define FREQ_50  (((PULSE_PER_KM * 50.0) / 3600.0))
#define FREQ_100  (((PULSE_PER_KM * 100.0) / 3600.0))
#define FREQ_150  (((PULSE_PER_KM * 150.0) / 3600.0))

// Min speed : 5km/h
#define MIN_SPEED 5 
#define MIN_FREQ (((PULSE_PER_KM * MIN_SPEED) / 3600.0))

// Timeout : min speed -15%
#define TIMEOUT_TICK (((1.0/((PULSE_PER_KM * MIN_SPEED * 0.85) / 3600.0)) / (TICK_VALUE)) / 1.0)  

uint16_t  gLastCounter = 0;
uint16_t  gInputPeriod = 0;
uint16_t  gOutputPeriod = 0;
uint16_t  gOverflowCounter = 0;
unsigned long gLastWriteLogTime = 0;
bool gStopped = true;
bool gCaptureLive = false;


bool gLastOutput = false;

String gInputString;
bool gStringComplete = false;

struct CorrectionItem
{
  uint16_t  inputPeriod;
  uint16_t  outputPeriod;
};

struct CorrectionFreq
{
  float inputFreq;
  float outputFreq;
};

// Speed correction table
// Each entry correspond to a point on the frequency correction curve
// First iten is always 0 => 0 to define the base of the curve.
CorrectionFreq gFreqTable[] = 
{
  {0.0, 0.0},
  {FREQ_50, FREQ_50},
  {FREQ_100, FREQ_100},
  {FREQ_150, FREQ_150}
};


void saveConf()
{
  int ee = 0;

  EEPROM.write(ee++, 'S');
  EEPROM.write(ee++, 'N');
  EEPROM.write(ee++, 'X');
  const byte* p = (const byte*)(const void*)gFreqTable;
  for (int i=0; i<sizeof(gFreqTable); ++i)
  {
        EEPROM.write(ee++, *p++);
  }
}

void loadConf()
{
  int ee = 0;
  char s, n, x;
  s = EEPROM.read(ee++);
  n = EEPROM.read(ee++);
  x = EEPROM.read(ee++);

  if (s != 'S' or n != 'N' or x != 'X')
  {
    Serial.println("No configuration found");
    return;
  }

  byte* p = (byte*)(void*)gFreqTable;
  for (int i=0; i<sizeof(gFreqTable); ++i)
  {
        *p++ = EEPROM.read(ee++);
  }
  Serial.println("Configuration loaded");
}

// Input capture interrupt routine for Speed input
ISR (TIMER1_CAPT_vect)
{
  cli();
  uint16_t tc1 = ICR1;

  if (gCaptureLive)
  {
    gInputPeriod = tc1 - gLastCounter;
  }
  gOverflowCounter = 0;
  gLastCounter = tc1;
  gCaptureLive = true;
  ICR1 = 0;

  sei();
}

// Timer 1 overflow interrupt
ISR (TIMER1_OVF_vect)
{
  cli();
  ++gOverflowCounter;
  
  sei();
}

ISR (TIMER1_COMPA_vect)
{
  cli();

  uint16_t counter = TCNT1;

  // check timeout (input freq is too slow)
  if (not gStopped)
  {
    gLastOutput = not gLastOutput;
    digitalWrite(13, gLastOutput);

    // program next event
    OCR1A = OCR1A + (gOutputPeriod >> 1);
  }

  sei();
}

void setup()
{
  // Input Capture setup
  // ICNC1: Enable Input Capture Noise Canceler
  // ICES1: =1 for trigger on rising edge
  // CS10+CS12: =1 set prescaler to 1024x system clock (F_CPU)
  TCCR1A = 0;
  TCCR1B = (1<<ICNC1) | (1<<ICES1) | (1<<CS10) | (1<<CS12);
  TCCR1C = 0;
   
  // initialize to catch Falling Edge
  TCCR1B &= ~(1<<ICES1); 
  TIFR1 |= (1<<ICF1); 
   
  // Interrupt setup
  // ICIE1: Input capture
  // TOIE1: Timer1 overflow
  TIFR1 = (1<<ICF1) | (1<<TOV1);	// clear pending interrupts
  TIMSK1 = (1<<ICIE1) | (1<<TOIE1);	// enable interupts

  // Set up the Input Capture pin, ICP1, Arduino Uno pin 8
  pinMode(8, INPUT);
  digitalWrite(8, 0);	// floating may have 60 Hz noise on it.
  //digitalWrite(8, 1); // or enable the pullup

  pinMode(13, OUTPUT);

  // activate output compare match interrupt
  TIMSK1 |= 1<<OCIE1A;

  gInputString.reserve(50);

  Serial.begin(9600);

  // load saved configuration
  loadConf();

  Serial.print("Init info : TICK = ");
  Serial.print(TICK_VALUE*1000*1000);
  Serial.print(", Timeout Tick = ");
  Serial.print(TIMEOUT_TICK);

  Serial.print(", F50 = ");
  Serial.print(FREQ_50);
  Serial.print("Hz F100 = ");
  Serial.print(FREQ_100);
  Serial.print("Hz F150 = ");
  Serial.print(PERIOD_150);
  Serial.println("Hz");

  Serial.println("Setup done");

}

void serialEvent()
{
//  Serial.println("Serial event !");
  while (Serial.available()) {
    // get the new byte:
    char inChar = (char)Serial.read();
    // if the incoming character is a newline, set a flag
    // so the main loop can do something about it:
    if (inChar == '\n') {
      gStringComplete = true;
      Serial.print("Line complete  : ");
      Serial.println(gInputString);
    }
    else
    {
      // add it to the inputString:
      gInputString += inChar;
    }
  }
}

int32_t myParseInt(const char*& it, const char* last)
{
  int32_t ret = 0;
  
  // skip any white space before
  while (it != last and *it == ' ')
    ++it;

  while( it != last)
  {
    char c = *it++;
    if (c >= '0' and c <= '9')
    {
      ret = (ret * 10) + (c - '0');
    }
    else
      break;
  }

  // skip any white space after
  while (it != last and *it == ' ')
    ++it;

  return ret;
}

void loop()
{
  unsigned long now = millis();

  // read input
  cli();
  uint16_t period = gInputPeriod;
  uint16_t lastCapture = gLastCounter;
  uint16_t overFlow = gOverflowCounter; 
  uint16_t currentPeriod = TCNT1 - lastCapture;

  // check for stop condition
  if (not gStopped and currentPeriod > TIMEOUT_TICK)
  {
    // input is stalled, stop output
    gOutputPeriod = 0;
    gInputPeriod = 0;
    digitalWrite(13, false);
    gLastOutput = false;
    gStopped = true;
    gCaptureLive = false;
  }
  sei();

  // Automatically decrease output freq if no input is seen
  if (not gStopped and period != 0 and currentPeriod > period)
    period = currentPeriod;

  // compute input freq based on input period
  float inFreq;

  if (period != 0)
    inFreq = 1.0 / (period * TICK_VALUE);
  else
    inFreq = 0.0;

  uint16_t outputPeriod;
  uint8_t index;
  
  // compute output period 

  // select the correction range
  if (inFreq < gFreqTable[1].inputFreq)
  {
    // Input speed is less than 50km/h   
    index = 1;
  }
  else if (inFreq < gFreqTable[2].inputFreq)
  {
    index = 2;
  }
  else
  {
    index = 3;
  }

  // Once index is determined,  
  // Compute out freq
  float outFreq = 0.0f;
  if (period != 0)
  {
    float di = gFreqTable[index].inputFreq - gFreqTable[index-1].inputFreq;
    float doo = gFreqTable[index].outputFreq - gFreqTable[index-1].outputFreq;
    outFreq = (inFreq - gFreqTable[index-1].inputFreq) / di * doo;
    outFreq += gFreqTable[index-1].outputFreq;

    // And convert to output period
    outputPeriod = (1.0 / outFreq) / TICK_VALUE;
  }
  else
  {
    outputPeriod = 0;
  }

  cli();
  // update output period param
  gOutputPeriod = outputPeriod;
  // need to program first timer ?
  if (gStopped and outputPeriod != 0)
  {
    OCR1A = TCNT1 + (outputPeriod >> 1);
    gStopped = false;
  }
  sei();

  // process input command
  if (gStringComplete)
  {
    Serial.println("Line received");

    if (gInputString == "SAVE")
    {
      Serial.println("Saving conf");
      saveConf();
    }
    else
    {
      // configure command :
      // Format is as follow:
      // INDEX IN_FREQ*1000 OUT_FREQ*1000
      //  with INDEX [1..3]
      // e.g :
      //   1 27000 29000
      //    => Set the correction point 1 to convert 27.000Hz to 29.000Hz
      
      const char* it = gInputString.c_str();
      const char* last = it + gInputString.length();
     
      int index = myParseInt(it, last);
  
      bool ok = it != last;
  
      if (not ok)
        Serial.println("Failed to parse index");
  
      float inVal = myParseInt(it, last) / 1000.0f;
      ok &= it != last;
  
      if (not ok)
        Serial.println("Failed to parse input");
      
      float outVal = myParseInt(it, last) / 1000.0f;
      ok &= it == last;
    
      if (not ok)
        Serial.println("Failed to parse output");
  
      ok &= index < 4;
  
      if (ok)
      {
        // apply the new value for the correction table
        gFreqTable[index].inputFreq = inVal;
        gFreqTable[index].outputFreq = outVal;
  
        Serial.print("Updated value : ");
        Serial.print(index);
        Serial.print(" : ");
        Serial.print(inVal);
        Serial.print(" - ");
        Serial.println(outVal);
      }
    }
    gInputString = "";
    gStringComplete = false;
  }
  
  // debug output
  if (now - gLastWriteLogTime > 1000)
  {
    Serial.print("Speed = ");
    Serial.print(inFreq * 3600.0f / 2000.0f);
    Serial.print("km/h ");
    Serial.print("Index : ");
    Serial.print(index);
    Serial.print(" : ");
    Serial.print(period);
    Serial.print(" - ");
    Serial.print(outputPeriod);
    Serial.print(" InF = ");
    Serial.print(inFreq);
    Serial.print("Hz, OutF = ");
    Serial.print(outFreq);
    Serial.print("Hz\n");

    for (int i = 0; i<4; ++i)
    {
      Serial.print(i);
      Serial.print(" : ");
      Serial.print(gFreqTable[i].inputFreq);
      Serial.print(" - ");
      Serial.print(gFreqTable[i].outputFreq);
      Serial.print("; ");
    }
    Serial.println("");
      
    gLastWriteLogTime = now;
  }
}

